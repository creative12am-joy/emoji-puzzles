<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Emoji Crossword ‚Äî Mega (18)</title>
  <style>
    :root { --bg:#f6f7fb; --panel:#fff; --text:#0f172a; --muted:#64748b; --accent:#6366f1; --danger:#ef4444; --ok:#16a34a; --grid:#cbd5e1; }
    * { box-sizing: border-box; }
    body { margin:0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji"; color:var(--text); background: linear-gradient(160deg,#f9fafb,#eef2ff 60%,#e2e8f0); }
    header { display:flex; align-items:center; justify-content:space-between; gap:12px; padding:16px 20px; }
    .title { display:flex; align-items:center; gap:10px; font-weight:700; font-size:20px; }
    .badge { background:#e2e8f0; color:#334155; border-radius:999px; padding:2px 10px; font-size:12px; }
    .toolbar { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    button { appearance:none; border:1px solid #cbd5e1; background:#fff; padding:8px 12px; border-radius:12px; cursor:pointer; font-weight:600; }
    button:hover { border-color:#94a3b8; }
    button.primary { background:var(--accent); color:#fff; border-color:transparent; }
    button.ghost { background:transparent; }
    button[disabled] { opacity:.45; cursor:not-allowed; }
    .container { max-width:820px; margin:0 auto; padding:0 16px 40px; }
    .card { background:var(--panel); border:1px solid #e2e8f0; border-radius:16px; box-shadow:0 6px 18px rgba(2,6,23,.06); }
    .card header { padding:14px 16px; border-bottom:1px solid #e5e7eb; }
    .card .body { padding:16px; }

    /* Single column layout: Grid on top, clue below */
    .gridHost { overflow:auto; max-width:100%; max-height:68vh; border:1px solid #e5e7eb; border-radius:12px; }
    .grid { display:grid; gap:0; user-select:none; }
    .cell { position:relative; width:44px; height:44px; border:1px solid var(--grid); background:#fff; display:flex; align-items:center; justify-content:center; }
    .block { background:#0b1220; border-color:#0b1220; }
    .cell input { width:100%; height:100%; text-align:center; font-size:22px; border:0; outline:none; background:transparent; text-transform:uppercase; caret-color:transparent; }
    .cell.wrong input { color: var(--danger); }
    .clueNo { position:absolute; left:3px; top:2px; font-size:10px; color:#475569; }
    .active { background:#eef2ff !important; }
    .selected { box-shadow:0 0 0 2px var(--accent) inset; z-index:2; }
    .wrong { box-shadow:0 0 0 2px var(--danger) inset; }
    .revealedMark { position:absolute; right:2px; bottom:2px; font-size:11px; }

    /* Current clue panel under the grid */
    .currentClue { margin-top:12px; border:1px solid #e2e8f0; border-radius:12px; padding:10px 12px; background:#fff; display:flex; align-items:center; gap:10px; min-height:44px; }
    .pill { font-size:12px; padding:3px 8px; border-radius:999px; background:#eef2ff; color:#3730a3; border:1px solid #c7d2fe; font-weight:700; }
    .emo { font-size:22px; line-height:1; }
    .muted { color:var(--muted); font-size:12px; }
    .footer { text-align:center; margin-top:12px; color:#64748b; font-size:12px; }

    .issues { display:none; }
    .toast { position:fixed; right:16px; bottom:16px; background:#111827; color:#fff; padding:10px 12px; border-radius:12px; box-shadow:0 6px 16px rgba(0,0,0,.2); display:none; }
  </style>
</head>
<body>
  <header>
    <div class="title">üß© Emoji Crossword ‚Äî Mega (18) <span class="badge">HTML</span></div>
    <div class="toolbar">
      <button id="toggleDir">Direction: Across</button>
      <button id="pauseBtn" class="ghost">‚è±Ô∏è Pause</button>
      <button id="resetBtn" class="ghost">üîÅ Reset</button>
      <button id="shareBtn" class="ghost">üì§ Share</button>
      <button id="kbdToggle" class="ghost">üîï Keyboard: Off</button>
      <span class="muted" id="timer">Time 00:00</span>
    </div>
  </header>

  <div class="container">
    <div class="card">
      <header>
        <div style="display:flex;align-items:center;justify-content:space-between;gap:8px;">
          <div style="font-weight:700;">Emoji Crossword ‚Äî Mega (18)</div>
          <div class="muted" id="status">Solve the puzzle!</div>
        </div>
      </header>
      <div class="body">
        <div id="gridWrap" class="gridHost"></div>
        <div id="currentClue" class="currentClue">
          <span class="muted">Tap any cell to see its clue</span>
        </div>
        <div style="display:grid; grid-template-columns:1fr 1fr; gap:8px; margin-top:12px;">
          <button id="checkCell" class="ghost">Check Cell</button>
          <button id="checkWord" class="ghost">Check Word</button>
          <button id="checkAll" class="primary">Check Crossword</button>
          <button id="revealLetter" class="ghost">Reveal Letter</button>
          <button id="revealWord" class="ghost">Reveal Word</button>
          <button id="nextWord" class="ghost">Next Word ‚ñ∂</button>
          <button id="undoBtn" class="ghost">‚Ü© Undo</button>
        </div>
        <div class="muted" style="margin-top:6px;">Shortcuts: letters, Backspace, Arrows, Space (toggle direction), Tab (next word), Ctrl/‚åò+Z (undo)</div>
        <div id="issues" class="issues"></div>
      </div>
    </div>
  </div>

  <div class="footer">Made with ‚ù§Ô∏è ‚Äî emoji-only clues; live error marking; undo; survey unlock & modal.</div>

  <div id="toast" class="toast">üéâ Crossword solved! Survey unlocked.</div>

  <!-- Survey Modal -->
  <div id="surveyModal" class="modal" role="dialog" aria-modal="true" aria-labelledby="surveyTitle" style="position:fixed; inset:0; background:rgba(0,0,0,.5); display:none; align-items:center; justify-content:center; padding:16px; z-index:1000;">
    <div class="modalCard" style="background:#fff; width:min(900px,96vw); height:min(720px,90vh); border-radius:12px; border:1px solid #e5e7eb; overflow:hidden; display:flex; flex-direction:column; box-shadow:0 20px 60px rgba(0,0,0,.35);">
      <div class="modalHeader" style="display:flex; align-items:center; justify-content:space-between; gap:8px; padding:8px 12px; border-bottom:1px solid #e5e7eb;">
        <div id="surveyTitle" class="title" style="font-size:16px; font-weight:700;">Survey</div>
        <div class="actions" style="display:flex; gap:8px;">
          <a id="surveyNewTab" href="#" target="_blank">Open in new tab ‚Üó</a>
          <button id="surveyClose" class="ghost">‚úñ Close</button>
        </div>
      </div>
      <div class="modalBody" style="flex:1;">
        <iframe id="surveyFrame" src="about:blank" title="Survey" style="width:100%; height:100%; border:0;"></iframe>
      </div>
    </div>
  </div>

<script>
(function(){
  // ===== CONFIG =====
  const SURVEY_URL = 'https://forms.gle/BnBNL8RD2pwLNmLt8';
  const DEFAULT_MIN_OVERLAPS = 1; // encourage interlocks
  const SHOW_ISSUES = false; // no dev panels for end users

  // ===== DATA (emoji-only clues) =====
  const RAW_ITEMS = [
    { emoji: "üè† + üîë", answer: "HOUSEKEY" },
    { emoji: "üß† + üå™Ô∏è", answer: "BRAINSTORM" },
    { emoji: "üêù + üçÉ", answer: "BELIEF" },
    { emoji: "üåä + üëÇ", answer: "WEAR" },
    { emoji: "ü•ö ‚û°Ô∏è üê£ ‚û°Ô∏è üê• ‚û°Ô∏è üêì", answer: "GROW" },
    { emoji: "üåï ‚û°Ô∏è üåñ ‚û°Ô∏è üåó ‚û°Ô∏è üåò ‚û°Ô∏è üåë", answer: "ECLIPSE" },
    { emoji: "üêé", answer: "HOARSE" },
    { emoji: "üçê", answer: "PAIR", force: 'down' },
    { emoji: "üåû + üìÖ", answer: "SUNDAY" },
    { emoji: "üöó + üêæ", answer: "CARPET" },
    { emoji: "üèô + üí§", answer: "GOODNIGHT" },
    { emoji: "ü¶Å + üëë", answer: "KING", mustWith: 'GOODNIGHT' },
    { emoji: "üïäÔ∏è + ‚òÆÔ∏è", answer: "PEACE" },
    { emoji: "üéµ + 2Ô∏è‚É£", answer: "TUNE" },
    { emoji: "üÖ±Ô∏è + 4Ô∏è‚É£", answer: "BEFORE" },
    { emoji: "üêù + üéÇ", answer: "BIRTHDAY", mustWith: 'GOODNIGHT', minOverlaps: 1, skipIfNoOverlap: true },
    { emoji: "üêò + ‚¨ÜÔ∏è", answer: "ELEVATE" },
    { emoji: "üêü + üêü", answer: "SELFISH" },
  ];
  const ITEMS = RAW_ITEMS.map(x => ({ ...x, answer: (x.answer||"").replace(/[^A-Za-z]/g,"").toUpperCase() }));

  // ===== UI refs =====
  const timerEl = document.getElementById('timer');
  const gridWrap = document.getElementById('gridWrap');
  const currentClueEl = document.getElementById('currentClue');
  const issuesEl = document.getElementById('issues');
  const surveyBtn = document.getElementById('surveyBtn');
  const surveyHint = document.getElementById('surveyHint'); // not present in this layout, but kept for compat
  const toast = document.getElementById('toast');
  const surveyModal = document.getElementById('surveyModal');
  const surveyFrame = document.getElementById('surveyFrame');
  const surveyNewTab = document.getElementById('surveyNewTab');
  const surveyClose = document.getElementById('surveyClose');
  const kbdToggle = document.getElementById('kbdToggle');
  const undoBtn = document.getElementById('undoBtn');

  // ===== Crossword builder (biased to tall rectangle) =====
  function buildBigCrossword(title, items){
    const occ = new Map(); // "r,c" -> letter
    const placements = []; // {emoji, answer, dir, row, col}
    const issues = [];

    const put=(r,c,ch)=>occ.set(`${r},${c}`,ch);
    const get=(r,c)=>occ.get(`${r},${c}`);

    const bounds=()=>{
      if(occ.size===0) return {minR:0,maxR:0,minC:0,maxC:0};
      let minR=1e9,maxR=-1e9,minC=1e9,maxC=-1e9;
      for(const k of occ.keys()){
        const [rs,cs]=k.split(",");
        const r=+rs,c=+cs; if(r<minR)minR=r;if(r>maxR)maxR=r;if(c<minC)minC=c;if(c>maxC)maxC=c;
      }
      return {minR,maxR,minC,maxC};
    };

    function canPlace(word,row,col,dir){
      for(let i=0;i<word.length;i++){
        const r = dir==='across'? row : row+i;
        const c = dir==='across'? col+i : col;
        const ex = get(r,c);
        if(ex && ex!==word[i]) return false;
        if(!ex){
          if(dir==='across'){
            if(get(r-1,c) || get(r+1,c)) return false; // vertical adjacency
          }else{
            if(get(r,c-1) || get(r,c+1)) return false; // horizontal adjacency
          }
        }
      }
      if(dir==='across'){
        if(get(row,col-1)) return false;
        if(get(row,col+word.length)) return false;
      }else{
        if(get(row-1,col)) return false;
        if(get(row+word.length,col)) return false;
      }
      return true;
    }

    function place(item){
      const emoji=item.emoji; const force=item.force||null; const mustWith=item.mustWith||null; const minOverlaps=item.minOverlaps ?? DEFAULT_MIN_OVERLAPS; const word=(item.answer||"").toUpperCase();
      if(!word) return;

      // First seed word is vertical (down) to bias a tall rectangle
      if(placements.length===0){
        for(let i=0;i<word.length;i++) put(i,0,word[i]);
        placements.push({emoji,answer:word,dir:'down',row:0,col:0});
        return;
      }

      const {minR,maxR,minC,maxC}=bounds();
      const cands=[]; // {row,col,dir,overlaps,area,width,height}
      for(const p of placements){
        if(mustWith && p.answer!==mustWith) continue; // only overlap target
        for(let i=0;i<word.length;i++){
          for(let j=0;j<p.answer.length;j++){
            if(word[i]!==p.answer[j]) continue;
            const dirCandidate = p.dir==='across'?'down':'across';
            if(force && dirCandidate!==force) continue; // obey forced dir
            const row = p.dir==='across'? p.row - i : p.row + j;
            const col = p.dir==='across'? p.col + j : p.col - i;
            if(!canPlace(word,row,col,dirCandidate)) continue;
            let overlaps=0; let minr=Math.min(minR,row), maxr=Math.max(maxR,row), minc=Math.min(minC, col), maxc=Math.max(maxC,col);
            for(let k=0;k<word.length;k++){
              const rr = dirCandidate==='across'? row : row+k;
              const cc = dirCandidate==='across'? col+k : col;
              if(get(rr,cc)===word[k]) overlaps++;
              if(rr<minr)minr=rr; if(rr>maxr)maxr=rr; if(cc<minc)minc=cc; if(cc>maxc)maxc=cc;
            }
            const width=(maxc-minc+1), height=(maxr-minr+1);
            const area=width*height;
            cands.push({row,col,dir:dirCandidate,overlaps,area,width,height});
          }
        }
      }
      // Prefer: more overlaps -> narrower width -> smaller area -> shorter height
      cands.sort((a,b)=> (b.overlaps-a.overlaps) || (a.width-b.width) || (a.area-b.area) || (a.height-b.height));

      let best = cands.find(c=>c.overlaps>=minOverlaps) || cands.find(c=>c.overlaps>0);
      if(best){
        for(let k=0;k<word.length;k++){
          const rr=best.dir==='across'? best.row : best.row+k;
          const cc=best.dir==='across'? best.col+k : best.col;
          put(rr,cc,word[k]);
        }
        placements.push({emoji,answer:word,dir:best.dir,row:best.row,col:best.col});
        return;
      }

      if(mustWith && item.skipIfNoOverlap){ issues.push(`Skipped: ${emoji} (${word}) ‚Äî cannot overlap ${mustWith}`); return; }

      // fallback: place isolated respecting force dir if any
      let tries=0; if(force==='down'){
        let r=0, c=maxC+2; while(!canPlace(word,r,c,'down') && tries<500){ c+=2; tries++; }
        if(tries>=500){ issues.push(`Cannot place (forced down): ${emoji} (${word})`); return; }
        for(let i=0;i<word.length;i++) put(r+i,c,word[i]); placements.push({emoji,answer:word,dir:'down',row:r,col:c});
      } else {
        let r=maxR+2, c=0; while(!canPlace(word,r,c,'across') && tries<500){ r+=2; tries++; }
        if(tries>=500){ issues.push(`Cannot place: ${emoji} (${word})`); return; }
        for(let i=0;i<word.length;i++) put(r,c+i,word[i]); placements.push({emoji,answer:word,dir:'across',row:r,col:c});
      }
    }

    for(const it of items) place(it);

    const {minR,maxR,minC,maxC}=bounds();
    const H = maxR-minR+1, W = maxC-minC+1;
    const grid = Array.from({length:H},()=>Array.from({length:W},()=> '#'));
    for(const [k,ch] of occ.entries()){
      const [rs,cs]=k.split(','); const r=+rs-minR, c=+cs-minC; grid[r][c]=ch; }

    const key=(r,c,d)=>`${r},${c},${d}`;
    const placeMap = new Map();
    for(const p of placements){ placeMap.set(key(p.row-minR,p.col-minC,p.dir), { ...p, row:p.row-minR, col:p.col-minC }); }

    const across=[], down=[]; let number=1; const at=(r,c)=> (r>=0&&r<H&&c>=0&&c<W? grid[r][c] : '#');
    for(let r=0;r<H;r++){
      for(let c=0;c<W;c++){
        if(at(r,c)==='#') continue;
        const startAcross = (c===0 || at(r,c-1)==='#') && (c+1<W && at(r,c+1)!=='#');
        const startDown   = (r===0 || at(r-1,c)==='#') && (r+1<H && at(r+1,c)!=='#');
        if(startAcross){
          const p=placeMap.get(key(r,c,'across')); let s=""; if(!p){ let cc=c; while(cc<W && at(r,cc)!=='#'){ s+=at(r,cc); cc++; } }
          across.push({ number, row:r, col:c, answer: p? p.answer : s, emoji: p? p.emoji : '‚ùì', dir:'across' }); number++;
        }
        if(startDown){
          const p=placeMap.get(key(r,c,'down')); let s=""; if(!p){ let rr=r; while(rr<H && at(rr,c)!=='#'){ s+=at(rr,c); rr++; } }
          down.push({ number, row:r, col:c, answer: p? p.answer : s, emoji: p? p.emoji : '‚ùì', dir:'down' }); number++;
        }
      }
    }

    return { puzzle: { id:'mega-18', title, grid: grid.map(row=>row.join('')), clues:{ across, down }, placements, offset:{minR,minC} }, issues };
  }

  // ===== Board builder =====
  function buildBoardFromPuzzle(puzzle){
    const issues=[];
    const rows=puzzle.grid.length; const cols=puzzle.grid[0].length;
    const board = Array.from({length:rows},(_,r)=> Array.from({length:cols},(_,c)=> ({ row:r,col:c,isBlock:puzzle.grid[r][c]==='#', value:"" })));

    function place(cl,dir){
      const ans = (cl.answer||"").toUpperCase(); const row=cl.row, col=cl.col;
      if(row<0||col<0||row>=rows||col>=cols){ issues.push(`${dir.toUpperCase()} ${cl.number} start out of bounds (${row},${col})`); return; }
      for(let i=0;i<ans.length;i++){
        const r= dir==='across'? row : row+i; const c= dir==='across'? col+i : col;
        if(r<0||c<0||r>=rows||c>=cols){ issues.push(`${dir.toUpperCase()} ${cl.number} overflows grid`); return; }
        const cell=board[r][c]; if(cell.isBlock){ issues.push(`${dir.toUpperCase()} ${cl.number} hits a block @(${r},${c})`); return; }
        if(cell.solution && cell.solution!==ans[i]){ issues.push(`${dir.toUpperCase()} ${cl.number} letter conflict @(${r},${c})`); return; }
      }
      for(let i=0;i<ans.length;i++){
        const r= dir==='across'? row : row+i; const c= dir==='across'? col+i : col; const cell=board[r][c];
        cell.solution=ans[i]; if(i===0) cell.clueNumber = cell.clueNumber ?? cl.number;
      }
    }

    (puzzle.clues.across||[]).forEach(cl=>place(cl,'across'));
    (puzzle.clues.down||[]).forEach(cl=>place(cl,'down'));

    return { board, issues };
  }

  // ===== State & controls =====
  const state = { dir:'across', cursor:null, seconds:0, running:true, solved:false, suppressKeyboard:true };
  const history = [];

  document.getElementById('toggleDir').onclick = ()=>{ state.dir = state.dir==='across'?'down':'across'; document.getElementById('toggleDir').textContent = `Direction: ${state.dir[0].toUpperCase()+state.dir.slice(1)}`; refreshActive(); };
  document.getElementById('pauseBtn').onclick = ()=>{ state.running=!state.running; document.getElementById('pauseBtn').textContent = state.running? '‚è±Ô∏è Pause' : '‚ñ∂ Resume'; };
  document.getElementById('resetBtn').onclick = ()=> reset();
  document.getElementById('shareBtn').onclick = ()=> share();
  document.getElementById('checkCell').onclick = ()=> check('cell');
  document.getElementById('checkWord').onclick = ()=> check('word');
  document.getElementById('checkAll').onclick = ()=> check('puzzle', /*fromUser*/ true);
  document.getElementById('revealLetter').onclick = ()=> reveal('letter');
  document.getElementById('revealWord').onclick = ()=> reveal('word');
  document.getElementById('nextWord').onclick = ()=> cycleWord(1);
  document.getElementById('undoBtn').onclick = ()=> undo();

  kbdToggle.onclick = ()=>{ state.suppressKeyboard = !state.suppressKeyboard; kbdToggle.textContent = state.suppressKeyboard ? 'üîï Keyboard: Off' : 'üî° Keyboard: On'; applyKeyboardMode(); };

  // timer
  setInterval(()=>{ if(state.running){ state.seconds++; const mm=String(Math.floor(state.seconds/60)).padStart(2,'0'); const ss=String(state.seconds%60).padStart(2,'0'); timerEl.textContent=`Time ${mm}:${ss}`; } }, 1000);

  // ===== Build
  let big, puzzle, built, board, issues, clueIdx;
  try {
    big = buildBigCrossword('Emoji Crossword ‚Äî Mega (18)', ITEMS);
    puzzle = big.puzzle;
    built = buildBoardFromPuzzle(puzzle);
    board = built.board;
    issues = [...(big.issues||[]), ...(built.issues||[])];

    // Build clue index by start cell + dir
    const key=(r,c,d)=>`${r},${c},${d}`; clueIdx = new Map();
    (puzzle.clues.across||[]).forEach(c=> clueIdx.set(key(c.row,c.col,'across'), c));
    (puzzle.clues.down||[]).forEach(c=> clueIdx.set(key(c.row,c.col,'down'), c));

    buildGrid();
    renderIssues();
    focusFirst();
    applyKeyboardMode();
    window.addEventListener('keydown', docKeydown, { capture:true });
  } catch (e) {
    console.error('Init error:', e);
    document.getElementById('status').textContent = 'Init error ‚Äî crossword failed to build';
  }

  // ===== Keyboard handling =====
  function applyKeyboardMode(){
    document.querySelectorAll('.cell input').forEach(inp=>{
      if(state.suppressKeyboard){ inp.readOnly = true; inp.setAttribute('inputmode','none'); inp.setAttribute('aria-readonly','true'); }
      else { inp.readOnly = false; inp.setAttribute('inputmode','text'); inp.removeAttribute('aria-readonly'); }
    });
  }

  function docKeydown(e){
    const cmd = (e.ctrlKey || e.metaKey) && !e.shiftKey;
    if(cmd && e.key.toLowerCase()==='z'){ e.preventDefault(); undo(); return; }
    if(!state.suppressKeyboard) return; // when keyboard is ON, let inputs handle
    const cur=state.cursor; if(!cur) return;
    const isLetter = e.key && /^[A-Za-z]$/.test(e.key);
    if(isLetter){ e.preventDefault(); writeAndAdvance(cur.row,cur.col,e.key,false); return; }
    switch(e.key){
      case 'Backspace': e.preventDefault(); backspaceSmart(); return;
      case ' ': e.preventDefault(); state.dir = state.dir==='across'?'down':'across'; document.getElementById('toggleDir').textContent = `Direction: ${state.dir[0].toUpperCase()+state.dir.slice(1)}`; refreshActive(); return;
      case 'Tab': e.preventDefault(); cycleWord(1); return;
      case 'ArrowLeft': e.preventDefault(); moveCursor(-1,0); return;
      case 'ArrowRight': e.preventDefault(); moveCursor(1,0); return;
      case 'ArrowUp': e.preventDefault(); moveCursor(0,-1); return;
      case 'ArrowDown': e.preventDefault(); moveCursor(0,1); return;
      default: return;
    }
  }

  // ===== Render helpers =====
  function buildGrid(){
    const rows=puzzle.grid.length, cols=puzzle.grid[0].length;
    const grid = document.createElement('div');
    grid.className='grid';
    grid.style.gridTemplateColumns = `repeat(${cols}, 44px)`;
    grid.style.gridTemplateRows = `repeat(${rows}, 44px)`;

    for(let r=0;r<rows;r++){
      for(let c=0;c<cols;c++){
        const cell = board[r][c];
        const div = document.createElement('div');
        div.className='cell'+(cell.isBlock?' block':'');
        div.dataset.r=r; div.dataset.c=c;
        if(!cell.isBlock){
          if(cell.clueNumber){ const small=document.createElement('span'); small.className='clueNo'; small.textContent=cell.clueNumber; div.appendChild(small); }
          const input=document.createElement('input');
          input.value=cell.value||''; input.maxLength=1;
          input.addEventListener('focus',()=>{ setCursor(r,c); });
          input.addEventListener('input',(e)=>{ const ch=(e.target.value||'').replace(/[^A-Za-z]/g,'').toUpperCase(); e.target.value=ch; writeAndAdvance(r,c,ch,false); });
          input.addEventListener('keydown',(e)=> handleKey(e,r,c));
          div.appendChild(input);
        }
        grid.appendChild(div);
      }
    }
    gridWrap.innerHTML=''; gridWrap.appendChild(grid);
  }

  function handleKey(e,r,c){
    if(/^([A-Za-z])$/.test(e.key)) return; // letters handled by input OR docKeydown
    if(e.key==='Backspace'){ e.preventDefault(); backspaceSmart(); return; }
    if(e.key===' '){ e.preventDefault(); state.dir = state.dir==='across'?'down':'across'; document.getElementById('toggleDir').textContent = `Direction: ${state.dir[0].toUpperCase()+state.dir.slice(1)}`; refreshActive(); return; }
    if(e.key==='Tab'){ e.preventDefault(); cycleWord(1); return; }
    if(e.key==='ArrowLeft'){ e.preventDefault(); moveCursor(-1,0); return; }
    if(e.key==='ArrowRight'){ e.preventDefault(); moveCursor(1,0); return; }
    if(e.key==='ArrowUp'){ e.preventDefault(); moveCursor(0,-1); return; }
    if(e.key==='ArrowDown'){ e.preventDefault(); moveCursor(0,1); return; }
  }

  function updateCurrentClue(){
    const cur=state.cursor; if(!cur){ currentClueEl.innerHTML = '<span class="muted">Tap any cell to see its clue</span>'; return; }
    const start = findWordStart(cur.row,cur.col,state.dir); const otherDir = state.dir==='across'?'down':'across'; const startOther = findWordStart(cur.row,cur.col,otherDir);
    const key=(r,c,d)=>`${r},${c},${d}`;
    let main = start ? clueIdx.get(key(start.row,start.col,state.dir)) : null;
    let alt  = startOther ? clueIdx.get(key(startOther.row,startOther.col,otherDir)) : null;
    const mainNum = main? main.number : '‚Äì'; const mainEmoji = main? (main.emoji||'') : '‚ùì';
    const hasAlt = !!alt;
    const dirLabel = state.dir==='across'?'A':'D';
    const altLabel = otherDir==='across'?'A':'D';
    currentClueEl.innerHTML = `<span class="pill">${mainNum}${dirLabel}</span> <span class="emo">${mainEmoji}</span>` + (hasAlt? `<span class="muted" style="margin-left:auto;">Also has <button id="switchDirBtn" class="ghost" style="padding:2px 8px; border-radius:999px;">Switch to ${altLabel}</button></span>` : '');
    const btn=document.getElementById('switchDirBtn'); if(btn){ btn.onclick=()=>{ state.dir = otherDir; document.getElementById('toggleDir').textContent = `Direction: ${state.dir[0].toUpperCase()+state.dir.slice(1)}`; refreshActive(); }; }
  }

  function renderIssues(){ if(!SHOW_ISSUES){ issuesEl.style.display='none'; return; } if(!issues.length){ issuesEl.style.display='none'; return; } issuesEl.style.display='block'; issuesEl.innerHTML = `<strong>Crossword Issues</strong><ul style="margin:6px 0 0 16px;">${issues.map(s=>`<li>${s}</li>`).join('')}</ul>`; }

  function focusFirst(){ for(let r=0;r<board.length;r++){ for(let c=0;c<board[0].length;c++){ if(!board[r][c].isBlock){ setCursor(r,c,true); return; } } } }

  function setCursor(r,c,focus=false){ state.cursor={row:r,col:c}; refreshActive(); if(focus){ const el=document.querySelector(`.cell[data-r="${r}"][data-c="${c}"] input`); if(el && !state.suppressKeyboard) el.focus(); } }

  function refreshActive(){ document.querySelectorAll('.cell').forEach(d=>d.classList.remove('active','selected')); const cur=state.cursor; if(!cur) return; const start = findWordStart(cur.row,cur.col,state.dir); const cells = getWordCells(start,state.dir); for(const cell of cells){ const el=document.querySelector(`.cell[data-r="${cell.row}"][data-c="${cell.col}"]`); if(el) el.classList.add('active'); } const sel=document.querySelector(`.cell[data-r="${cur.row}"][data-c="${cur.col}"]`); if(sel) sel.classList.add('selected'); updateCurrentClue(); }

  function findWordStart(row,col,dir){ if(row<0||col<0||row>=board.length||col>=board[0].length) return null; if(board[row][col].isBlock) return null; let r=row,c=col; if(dir==='across'){ while(c-1>=0 && !board[r][c-1].isBlock) c--; } else { while(r-1>=0 && !board[r-1][c].isBlock) r--; } return {row:r,col:c}; }

  function getWordCells(start,dir){ const out=[]; if(!start) return out; let {row,col}=start; const R=board.length, C=board[0].length; while(row>=0 && row<R && col>=0 && col<C && !board[row][col].isBlock){ out.push(board[row][col]); if(dir==='across') col++; else row++; } return out; }

  function updateCellDom(row,col){ const cell=board[row][col]; const host=document.querySelector(`.cell[data-r="${row}"][data-c="${col}"]`); if(!host) return; const input=host.querySelector('input'); if(input && input.value !== (cell.value||'')) input.value = cell.value||''; const wrong = !!cell.value && cell.solution && cell.value !== cell.solution; host.classList.toggle('wrong', wrong); }

  function writeAndAdvance(row,col,ch,back){ const cell=board[row][col]; if(cell.isBlock) return; const prev = cell.value||''; const next = (ch||'').toUpperCase(); if(prev !== next){ history.push({row,col,prev,next}); } cell.value = next; updateCellDom(row,col); const start=findWordStart(row,col,state.dir); const cells=getWordCells(start,state.dir); const idx=cells.findIndex(cc=>cc.row===row&&cc.col===col); if(back){ if(idx>0){ setCursor(cells[idx-1].row, cells[idx-1].col, true); } else { if(state.dir==='across'){ let c=col-1; while(c>=0 && !board[row][c].isBlock){ setCursor(row,c,true); return; } } else { let r=row-1; while(r>=0 && !board[r][col].isBlock){ setCursor(r,col,true); return; } } setCursor(row,col,true); } } else { if(idx < cells.length-1){ setCursor(cells[idx+1].row, cells[idx+1].col, true); } else setCursor(row,col,true); } checkAutoSolved(); }

  function backspaceSmart(){ const cur=state.cursor; if(!cur) return; const cell=board[cur.row][cur.col]; if(cell.value){ writeAndAdvance(cur.row,cur.col,'',true); } else { const start=findWordStart(cur.row,cur.col,state.dir); const cells=getWordCells(start,state.dir); const idx=cells.findIndex(cc=>cc.row===cur.row&&cc.col===cur.col); if(idx>0){ const prev=cells[idx-1]; setCursor(prev.row,prev.col,true); writeAndAdvance(prev.row,prev.col,'',true); } else { if(state.dir==='across'){ let c=cur.col-1; while(c>=0 && !board[cur.row][c].isBlock){ setCursor(cur.row,c,true); writeAndAdvance(cur.row,c,'',true); return; } } else { let r=cur.row-1; while(r>=0 && !board[r][cur.col].isBlock){ setCursor(r,cur.col,true); writeAndAdvance(r,cur.col,'',true); return; } } } } }

  function moveCursor(dx,dy){ const cur=state.cursor; if(!cur) return; let r=cur.row+dy, c=cur.col+dx; const R=board.length,C=board[0].length; while(r>=0&&r<R&&c>=0&&c<C&&board[r][c].isBlock){ r+=dy; c+=dx; } if(r>=0&&r<R&&c>=0&&c<C) setCursor(r,c,true); }

  function cycleWord(step){ const starts=[]; const R=board.length,C=board[0].length; for(let r=0;r<R;r++) for(let c=0;c<C;c++){ if(board[r][c].isBlock) continue; const aStart = (c===0||board[r][c-1].isBlock) && (c+1<C && !board[r][c+1].isBlock); const dStart = (r===0||board[r-1][c].isBlock) && (r+1<R && !board[r+1][c].isBlock); if(aStart) starts.push({row:r,col:c,dir:'across'}); if(dStart) starts.push({row:r,col:c,dir:'down'}); } const cur=state.cursor; const s=findWordStart(cur.row,cur.col,state.dir); const i=starts.findIndex(x=>s&&x.row===s.row&&x.col===s.col&&x.dir===state.dir); const j=(i+step+starts.length)%starts.length; const nxt=starts[j]; state.dir=nxt.dir; setCursor(nxt.row,nxt.col,true); }

  function check(kind, fromUser){ let correctAll=true; const mark=(cell)=>{ if(cell.isBlock||!cell.solution) return; const good=(cell.value||'')===cell.solution; cell.isCorrect=good; const el=document.querySelector(`.cell[data-r="${cell.row}"][data-c="${cell.col}"]`); if(el){ el.classList.toggle('wrong', !good && !!cell.value); } if(!good) correctAll=false; }; if(kind==='cell' && state.cursor){ mark(board[state.cursor.row][state.cursor.col]); } else if(kind==='word' && state.cursor){ const start=findWordStart(state.cursor.row,state.cursor.col,state.dir); for(const c of getWordCells(start,state.dir)) mark(c); } else { for(const row of board) for(const c of row) mark(c); } if(kind==='puzzle'){ document.getElementById('status').textContent = correctAll? 'üéâ All correct! Survey is now open.' : 'Some cells are wrong.'; if(correctAll) onPuzzleSolved(fromUser); } }

  function reveal(kind){ if(!state.cursor) return; const rev=(cell)=>{ if(cell.isBlock||!cell.solution) return; const prev=cell.value||''; cell.value=cell.solution; history.push({row:cell.row,col:cell.col,prev,next:cell.value}); updateCellDom(cell.row,cell.col); const mark=document.createElement('span'); mark.className='revealedMark'; mark.textContent='üëÄ'; const host=document.querySelector(`.cell[data-r="${cell.row}"][data-c="${cell.col}"]`); if(host && !host.querySelector('.revealedMark')) host.appendChild(mark); }; if(kind==='letter'){ rev(board[state.cursor.row][state.cursor.col]); } else { const start=findWordStart(state.cursor.row,state.cursor.col,state.dir); for(const c of getWordCells(start,state.dir)) rev(c); } checkAutoSolved(); }

  function undo(){ const last = history.pop(); if(!last) return; const {row,col,prev} = last; const cell=board[row][col]; cell.value = prev||''; updateCellDom(row,col); setCursor(row,col,true); }

  function isAllCorrect(){ for(const row of board){ for(const cell of row){ if(cell.isBlock) continue; if((cell.value||'') !== (cell.solution||'')) return false; } } return true; }

  function checkAutoSolved(){ if(!state.solved && isAllCorrect()){ onPuzzleSolved(false); } }

  function openSurveyModal(){ surveyFrame.src = SURVEY_URL; surveyNewTab.href = SURVEY_URL; surveyModal.style.display = 'flex'; }
  function closeSurveyModal(){ surveyModal.style.display = 'none'; surveyFrame.src = 'about:blank'; }

  function onPuzzleSolved(fromUser){ if(state.solved) return; state.solved=true; if(surveyBtn) surveyBtn.disabled = false; if(surveyHint) surveyHint.textContent = 'Survey unlocked'; toast.style.display='block'; setTimeout(()=> toast.style.display='none', 2500); openSurveyModal(); }

  if(document.getElementById('surveyClose')) document.getElementById('surveyClose').onclick = closeSurveyModal;
  if(surveyModal) surveyModal.addEventListener('click', (e)=> { if(e.target===surveyModal) closeSurveyModal(); });

  function reset(){ state.seconds=0; state.running=true; state.solved=false; document.getElementById('status').textContent='Solve the puzzle!'; if(surveyBtn) surveyBtn.disabled=true; if(surveyHint) surveyHint.textContent='Survey unlocks after you finish the crossword'; history.length=0; const rebuilt = buildBoardFromPuzzle(puzzle); board=rebuilt.board; issues=[...big.issues, ...rebuilt.issues]; buildGrid(); renderIssues(); focusFirst(); applyKeyboardMode(); closeSurveyModal(); }

  function share(){ let out=[]; for(let r=0;r<board.length;r++){ let line=''; for(let c=0;c<board[0].length;c++){ const cell=board[r][c]; if(cell.isBlock) line+='‚¨õ'; else if(!cell.value) line+='‚¨ú'; else line += (cell.value===cell.solution? 'üü©':'üü•'); } out.push(line); } const mins=Math.floor(state.seconds/60), secs=String(state.seconds%60).padStart(2,'0'); const text=`${puzzle.title}\nTime ${mins}:${secs}\n${out.join('\n')}`; navigator.clipboard.writeText(text).then(()=> document.getElementById('status').textContent='Copied results to clipboard!'); }
})();
</script>
</body>
</html>
