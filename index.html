<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Emoji Crossword — Mega (18)</title>
  <style>
    :root {
      --bg:#f6f7fb; --panel:#fff; --text:#0f172a; --muted:#64748b; --accent:#6366f1; --danger:#ef4444; --ok:#16a34a; --grid:#cbd5e1;
      --cell: clamp(42px, 10vw, 56px);
      --vh: 1vh;
      --vkH: 0px; /* runtime set when virtual keyboard visible */
      --clueH: 52px; /* floating clue bar height */
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin:0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Noto Color Emoji", "Apple Color Emoji", "Segoe UI Emoji";
      color:var(--text); background: linear-gradient(160deg,#f9fafb,#eef2ff 60%,#e2e8f0);
      -webkit-tap-highlight-color: transparent;
      padding-bottom: calc(var(--vkH) + var(--clueH) + env(safe-area-inset-bottom, 0px) + 10px);
    }
    /* Compact, two-line header on mobile */
    header { display:flex; flex-direction:column; align-items:stretch; gap:6px; padding:8px 10px; }
    .title { display:flex; align-items:center; gap:8px; font-weight:700; font-size:16px; line-height:1.2; }
    .badge { background:#e2e8f0; color:#334155; border-radius:999px; padding:2px 8px; font-size:11px; }
    .toolbar { display:flex; flex-wrap:wrap; gap:6px; }
    button { appearance:none; border:1px solid #cbd5e1; background:#fff; padding:8px 10px; border-radius:12px; cursor:pointer; font-weight:700; min-height:36px; touch-action: manipulation; font-size:14px; }
    button:hover { border-color:#94a3b8; }
    button.primary { background:var(--accent); color:#fff; border-color:transparent; }
    button.ghost { background:transparent; }
    button[disabled] { opacity:.45; cursor:not-allowed; }

    .container { max-width:860px; margin:0 auto; padding:0 12px 20px; }
    .card { background:var(--panel); border:1px solid #e2e8f0; border-radius:16px; box-shadow:0 6px 18px rgba(2,6,23,.06); }
    .card header { padding:10px 12px; border-bottom:1px solid #e5e7eb; }
    .card .body { position:relative; padding:12px; }

    .gridHost { overflow:auto; max-width:100%; max-height: calc(var(--vh) * 70); border:1px solid #e5e7eb; border-radius:12px; overscroll-behavior: contain; background:#fff; }
    .grid { display:grid; gap:0; user-select:none; }
    .cell { position:relative; width:var(--cell); height:var(--cell); border:1px solid var(--grid); background:#fff; display:flex; align-items:center; justify-content:center; }
    .block { background:#0b1220; border-color:#0b1220; }
    .cell input { width:100%; height:100%; text-align:center; border:0; outline:none; background:transparent; text-transform:uppercase; caret-color:transparent; touch-action: manipulation; font-size: max(20px, 1rem); }
    .cell.wrong input { color: var(--danger); }
    .clueNo { position:absolute; left:3px; top:2px; font-size:10px; color:#475569; pointer-events:none; }
    .active { background:#eef2ff !important; }
    .selected { box-shadow:0 0 0 2px var(--accent) inset; z-index:2; }
    .wrong { box-shadow:0 0 0 2px var(--danger) inset; }
    .revealedMark { position:absolute; right:2px; bottom:2px; font-size:11px; }

    /* Floating current clue (overlay) */
    .floatingClue {
      position: fixed; left: 50%; transform: translateX(-50%);
      bottom: calc(var(--vkH) + env(safe-area-inset-bottom, 0px) + 6px);
      width: min(860px, 96vw);
      display:flex; align-items:center; gap:6px; min-height:var(--clueH);
      border:1px solid #e2e8f0; border-radius:12px; background:#ffffffee; backdrop-filter: blur(6px);
      box-shadow:0 8px 24px rgba(2,6,23,.18);
      padding:8px 10px; z-index:1000;
    }
    .pill { font-size:12px; padding:5px 8px; border-radius:999px; background:#eef2ff; color:#3730a3; border:1px solid #c7d2fe; font-weight:800; min-width:38px; text-align:center; }
    .emo { font-size:22px; line-height:1; white-space:nowrap; }
    .muted { color:var(--muted); font-size:12px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
    .ops { margin-left:auto; display:flex; gap:6px; }
    .ops button{ min-height:30px; padding:4px 8px; font-size:16px; border-radius:10px; width:auto; line-height:1; position:relative; }
    .ops button.icon{ width:34px; min-width:34px; padding:4px 0; text-align:center; }
    .ops button[data-badge]:after{ content: attr(data-badge); position:absolute; right:-2px; top:-4px; font-size:10px; background:#1f2937; color:#fff; border-radius:8px; padding:0 3px; border:1px solid #fff; }

    /* Floating virtual keyboard — compact */
    .vk {
      position: fixed; left: 50%; transform: translateX(-50%);
      bottom: env(safe-area-inset-bottom, 0px);
      width: min(860px, 96vw);
      background:#0b1220; color:#e5e7eb; border-radius:14px 14px 0 0; box-shadow:0 -8px 26px rgba(2,6,23,.4);
      padding:6px; z-index:999; display:none; overflow-x:auto;
    }
    .vk .row { display:flex; gap:4px; justify-content:center; margin:4px 0; }
    .vk button { flex: 0 0 auto; min-width: 30px; min-height: 36px; border-radius:10px; border:1px solid #1f2937; background:#111827; color:#e5e7eb; font-weight:800; font-size:14px; padding:6px 8px; }
    .vk button.action { background:#1f2937; }
    .vk .space { min-width: 28%; }

    .footer { text-align:center; margin-top:12px; color:#64748b; font-size:12px; }
    .issues { display:none; }
    .toast { position:fixed; right:12px; bottom:calc(var(--vkH) + var(--clueH) + 20px); background:#111827; color:#fff; padding:10px 12px; border-radius:12px; box-shadow:0 6px 16px rgba(0,0,0,.2); display:none; z-index:1001; }

    @media (min-width: 920px) {
      header { flex-direction:row; align-items:center; justify-content:space-between; padding:12px 14px; }
      .title { font-size:18px; }
      .container { padding-bottom:28px; }
    }
  </style>
</head>
<body>
  <header>
    <div class="title">Emoji Crossword — Mega (18) <span class="badge">HTML</span></div>
    <div class="toolbar">
      <button id="toggleDir">Direction: Across</button>
      <button id="pauseBtn" class="ghost">⏱️ Pause</button>
      <button id="resetBtn" class="ghost">Reset</button>
      <button id="shareBtn" class="ghost">Share</button>
      <button id="kbdToggle" class="ghost">On‑Screen Keyboard</button>
      <span class="muted" id="timer">Time 00:00</span>
    </div>
  </header>

  <div class="container">
    <div class="card">
      <header>
        <div style="display:flex;align-items:center;justify-content:space-between;gap:8px;">
          <div style="font-weight:700;">Emoji Crossword — Mega (18)</div>
          <div class="muted" id="status">Solve the puzzle!</div>
        </div>
      </header>
      <div class="body">
        <div id="gridWrap" class="gridHost"></div>
        <div id="issues" class="issues"></div>
      </div>
    </div>
  </div>

  <!-- Floating elements -->
  <div id="currentClue" class="floatingClue" aria-live="polite">
    <span class="muted">Tap any cell to see its clue</span>
  </div>
  <div id="vk" class="vk" aria-label="On-screen keyboard" role="group"></div>

  <div class="footer">Mobile‑first • floating clue & on‑screen keyboard • undo • auto‑survey</div>
  <div id="toast" class="toast">Crossword solved! Survey unlocked.</div>

  <!-- Survey Modal -->
  <div id="surveyModal" class="modal" role="dialog" aria-modal="true" aria-labelledby="surveyTitle" style="position:fixed; inset:0; background:rgba(0,0,0,.5); display:none; align-items:center; justify-content:center; padding:16px; z-index:1100;">
    <div class="modalCard" style="background:#fff; width:min(900px,96vw); height:min(720px,90vh); border-radius:12px; border:1px solid #e5e7eb; overflow:hidden; display:flex; flex-direction:column; box-shadow:0 20px 60px rgba(0,0,0,.35);">
      <div class="modalHeader" style="display:flex; align-items:center; justify-content:space-between; gap:8px; padding:8px 12px; border-bottom:1px solid #e5e7eb;">
        <div id="surveyTitle" class="title" style="font-size:16px; font-weight:700;">Survey</div>
        <div class="actions" style="display:flex; gap:8px;">
          <a id="surveyNewTab" href="#" target="_blank" rel="noopener noreferrer">Open in new tab ↗</a>
          <button id="surveyClose" class="ghost">Close</button>
        </div>
      </div>
      <div class="modalBody" style="flex:1;">
        <iframe id="surveyFrame" src="about:blank" title="Survey" style="width:100%; height:100%; border:0;"></iframe>
      </div>
    </div>
  </div>

<script>
(function(){
  // ===== Mobile viewport height fix =====
  function setVh(){
    const vh = window.innerHeight * 0.01;
    document.documentElement.style.setProperty('--vh', `${vh}px`);
  }
  setVh();
  window.addEventListener('resize', setVh);

  // ===== CONFIG =====
  const SURVEY_URL = 'https://forms.gle/BnBNL8RD2pwLNmLt8';
  const DEFAULT_MIN_OVERLAPS = 1;
  const SHOW_ISSUES = false;

  // ===== DATA (emoji-only clues) =====
  const RAW_ITEMS = [
    { emoji: "🏠 + 🔑", answer: "HOUSEKEY" },
    { emoji: "🧠 + 🌪️", answer: "BRAINSTORM" },
    { emoji: "🐝 + 🍃", answer: "BELIEF" },
    { emoji: "🌊 + 👂", answer: "WEAR" },
    { emoji: "🥚 ➡️ 🐣 ➡️ 🐥 ➡️ 🐓", answer: "GROW" },
    { emoji: "🌕 ➡️ 🌖 ➡️ 🌗 ➡️ 🌘 ➡️ 🌑", answer: "ECLIPSE" },
    { emoji: "🐎", answer: "HOARSE" },
    { emoji: "🍐", answer: "PAIR", force: 'down' },
    { emoji: "🌞 + 📅", answer: "SUNDAY" },
    { emoji: "🚗 + 🐾", answer: "CARPET" },
    { emoji: "🏙 + 💤", answer: "GOODNIGHT" },
    { emoji: "🦁 + 👑", answer: "KING", mustWith: 'GOODNIGHT' },
    { emoji: "🕊️ + ☮️", answer: "PEACE" },
    { emoji: "🎵 + 2️⃣", answer: "TUNE" },
    { emoji: "🅱️ + 4️⃣", answer: "BEFORE" },
    { emoji: "🐝 + 🎂", answer: "BIRTHDAY", mustWith: 'GOODNIGHT', minOverlaps: 1, skipIfNoOverlap: true },
    { emoji: "🐘 + ⬆️", answer: "ELEVATE" },
    { emoji: "🐟 + 🐟", answer: "SELFISH" },
  ];
  const ITEMS = RAW_ITEMS.map(x => ({ ...x, answer: (x.answer||"").replace(/[^A-Za-z]/g,"").toUpperCase() }));

  // ===== UI refs =====
  const timerEl = document.getElementById('timer');
  const gridWrap = document.getElementById('gridWrap');
  const currentClueEl = document.getElementById('currentClue');
  const issuesEl = document.getElementById('issues');
  const toast = document.getElementById('toast');
  const surveyModal = document.getElementById('surveyModal');
  const surveyFrame = document.getElementById('surveyFrame');
  const surveyNewTab = document.getElementById('surveyNewTab');
  const surveyClose = document.getElementById('surveyClose');
  const kbdToggle = document.getElementById('kbdToggle');
  const vk = document.getElementById('vk');

  // ===== Crossword builder (biased to tall rectangle) =====
  function buildBigCrossword(title, items){
    const occ = new Map();
    const placements = [];
    const issues = [];
    const put=(r,c,ch)=>occ.set(`${r},${c}`,ch);
    const get=(r,c)=>occ.get(`${r},${c}`);

    const bounds=()=>{
      if(occ.size===0) return {minR:0,maxR:0,minC:0,maxC:0};
      let minR=1e9,maxR=-1e9,minC=1e9,maxC=-1e9;
      for(const k of occ.keys()){
        const [rs,cs]=k.split(",");
        const r=+rs,c=+cs; if(r<minR)minR=r;if(r>maxR)maxR=r;if(c<minC)minC=c;if(c>maxC)maxC=c;
      }
      return {minR,maxR,minC,maxC};
    };

    function canPlace(word,row,col,dir){
      for(let i=0;i<word.length;i++){
        const r = dir==='across'? row : row+i;
        const c = dir==='across'? col+i : col;
        const ex = get(r,c);
        if(ex && ex!==word[i]) return false;
        if(!ex){
          if(dir==='across'){
            if(get(r-1,c) || get(r+1,c)) return false;
          }else{
            if(get(r,c-1) || get(r,c+1)) return false;
          }
        }
      }
      if(dir==='across'){
        if(get(row,col-1)) return false;
        if(get(row,col+word.length)) return false;
      }else{
        if(get(row-1,col)) return false;
        if(get(row+word.length,col)) return false;
      }
      return true;
    }

    function place(item){
      const emoji=item.emoji; const force=item.force||null; const mustWith=item.mustWith||null; const minOverlaps=item.minOverlaps ?? 1; const word=(item.answer||"").toUpperCase();
      if(!word) return;
      if(placements.length===0){ for(let i=0;i<word.length;i++) put(i,0,word[i]); placements.push({emoji,answer:word,dir:'down',row:0,col:0}); return; }

      const {minR,maxR,minC,maxC}=bounds();
      const cands=[];
      for(const p of placements){
        if(mustWith && p.answer!==mustWith) continue;
        for(let i=0;i<word.length;i++){
          for(let j=0;j<p.answer.length;j++){
            if(word[i]!==p.answer[j]) continue;
            const dirCandidate = p.dir==='across'?'down':'across';
            if(force && dirCandidate!==force) continue;
            const row = p.dir==='across'? p.row - i : p.row + j;
            const col = p.dir==='across'? p.col + j : p.col - i;
            if(!canPlace(word,row,col,dirCandidate)) continue;
            let overlaps=0; let minr=Math.min(minR,row), maxr=Math.max(maxR,row), minc=Math.min(minC,col), maxc=Math.max(maxC,col);
            for(let k=0;k<word.length;k++){
              const rr = dirCandidate==='across'? row : row+k;
              const cc = dirCandidate==='across'? col+k : col;
              if(get(rr,cc)===word[k]) overlaps++;
              if(rr<minr)minr=rr; if(rr>maxr)maxr=rr; if(cc<minc)minc=cc; if(cc>maxc)maxc=cc;
            }
            const width=(maxc-minc+1), height=(maxr-minr+1), area=width*height;
            cands.push({row,col,dir:dirCandidate,overlaps,area,width,height});
          }
        }
      }
      cands.sort((a,b)=> (b.overlaps-a.overlaps) || (a.width-b.width) || (a.area-b.area) || (a.height-b.height));
      let best = cands.find(c=>c.overlaps>=minOverlaps) || cands.find(c=>c.overlaps>0);
      if(best){ for(let k=0;k<word.length;k++){ const rr=best.dir==='across'? best.row : best.row+k; const cc=best.dir==='across'? best.col+k : best.col; put(rr,cc,word[k]); } placements.push({emoji,answer:word,dir:best.dir,row:best.row,col:best.col}); return; }
      if(mustWith && item.skipIfNoOverlap) return;
      let tries=0; if(force==='down'){ let r=0, c=maxC+2; while(!canPlace(word,r,c,'down') && tries<500){ c+=2; tries++; } if(tries>=500) return; for(let i=0;i<word.length;i++) put(r+i,c,word[i]); placements.push({emoji,answer:word,dir:'down',row:r,col:c}); } else { let r=maxR+2, c=0; while(!canPlace(word,r,c,'across') && tries<500){ r+=2; tries++; } if(tries>=500) return; for(let i=0;i<word.length;i++) put(r,c+i,word[i]); placements.push({emoji,answer:word,dir:'across',row:r,col:c}); }
    }

    for(const it of items) place(it);

    const {minR,maxR,minC,maxC}=bounds();
    const H = maxR-minR+1, W = maxC-minC+1;
    const grid = Array.from({length:H},()=>Array.from({length:W},()=> '#'));
    for(const [k,ch] of occ.entries()){
      const [rs,cs]=k.split(','); const r=+rs-minR, c=+cs-minC; grid[r][c]=ch; }

    const key=(r,c,d)=>`${r},${c},${d}`;
    const placeMap = new Map();
    for(const p of placements){ placeMap.set(key(p.row-minR,p.col-minC,p.dir), { ...p, row:p.row-minR, col:p.col-minC }); }

    const across=[], down=[]; let number=1; const at=(r,c)=> (r>=0&&r<H&&c>=0&&c<W? grid[r][c] : '#');
    for(let r=0;r<H;r++){
      for(let c=0;c<W;c++){
        if(at(r,c)==='#') continue;
        const startAcross = (c===0 || at(r,c-1)==='#') && (c+1<W && at(r,c+1)!=='#');
        const startDown   = (r===0 || at(r-1,c)==='#') && (r+1<H && at(r+1,c)!=='#');
        if(startAcross){ const p=placeMap.get(key(r,c,'across')); let s=""; if(!p){ let cc=c; while(cc<W && at(r,cc)!=='#'){ s+=at(r,cc); cc++; } } across.push({ number, row:r, col:c, answer: p? p.answer : s, emoji: p? p.emoji : '❓', dir:'across' }); number++; }
        if(startDown){ const p=placeMap.get(key(r,c,'down')); let s=""; if(!p){ let rr=r; while(rr<H && at(rr,c)!=='#'){ s+=at(rr,c); rr++; } } down.push({ number, row:r, col:c, answer: p? p.answer : s, emoji: p? p.emoji : '❓', dir:'down' }); number++; }
      }
    }

    return { puzzle: { id:'mega-18', title, grid: grid.map(row=>row.join('')), clues:{ across, down }, placements, offset:{minR,minC} }, issues };
  }

  // ===== Board builder =====
  function buildBoardFromPuzzle(puzzle){
    const rows=puzzle.grid.length; const cols=puzzle.grid[0].length;
    const board = Array.from({length:rows},(_,r)=> Array.from({length:cols},(_,c)=> ({ row:r,col:c,isBlock:puzzle.grid[r][c]==='#', value:"" })));
    function place(cl,dir){ const ans=(cl.answer||"").toUpperCase(); const row=cl.row, col=cl.col; for(let i=0;i<ans.length;i++){ const r= dir==='across'? row : row+i; const c= dir==='across'? col+i : col; const cell=board[r][c]; cell.solution=ans[i]; if(i===0) cell.clueNumber = cell.clueNumber ?? cl.number; } }
    (puzzle.clues.across||[]).forEach(cl=>place(cl,'across'));
    (puzzle.clues.down||[]).forEach(cl=>place(cl,'down'));
    return { board };
  }

  // ===== State & controls =====
  const state = { dir:'across', cursor:null, seconds:0, running:true, solved:false, suppressKeyboard:true };
  const history = [];
  let cellEls = [];
  let puzzle, board, clueIdx, big;

  document.getElementById('toggleDir').onclick = ()=>{ state.dir = state.dir==='across'?'down':'across'; document.getElementById('toggleDir').textContent = `Direction: ${state.dir[0].toUpperCase()+state.dir.slice(1)}`; refreshActive(); };
  document.getElementById('pauseBtn').onclick = ()=>{ state.running=!state.running; document.getElementById('pauseBtn').textContent = state.running? '⏱️ Pause' : '▶ Resume'; };
  document.getElementById('resetBtn').onclick = ()=> reset();
  document.getElementById('shareBtn').onclick = ()=> share();

  kbdToggle.onclick = ()=>{
    state.suppressKeyboard = true; // keep inputs readOnly to prevent native IME
    const visible = vk.style.display === 'block';
    setVkVisible(!visible);
  };

  // timer
  setInterval(()=>{ if(state.running){ state.seconds++; const mm=String(Math.floor(state.seconds/60)).padStart(2,'0'); const ss=String(state.seconds%60).padStart(2,'0'); timerEl.textContent=`Time ${mm}:${ss}`; } }, 1000);

  // ===== Build =====
  try {
    big = buildBigCrossword('Emoji Crossword — Mega (18)', ITEMS);
    puzzle = big.puzzle;
    board = buildBoardFromPuzzle(puzzle).board;

    const key=(r,c,d)=>`${r},${c},${d}`; clueIdx = new Map();
    (puzzle.clues.across||[]).forEach(c=> clueIdx.set(key(c.row,c.col,'across'), c));
    (puzzle.clues.down||[]).forEach(c=> clueIdx.set(key(c.row,c.col,'down'), c));

    buildGrid();
    buildVirtualKeyboard();
    focusFirst();
    applyKeyboardMode();
    window.addEventListener('keydown', docKeydown, { capture:true });
  } catch (e) {
    console.error('Init error:', e);
    document.getElementById('status').textContent = 'Init error — crossword failed to build';
  }

  // ===== Keyboard handling =====
  function applyKeyboardMode(){
    document.querySelectorAll('.cell input').forEach(inp=>{
      inp.readOnly = true; // always suppress native keyboard on mobile for consistency
      inp.setAttribute('inputmode','none'); inp.setAttribute('aria-readonly','true'); inp.setAttribute('autocomplete','off'); inp.setAttribute('autocorrect','off'); inp.setAttribute('autocapitalize','characters'); inp.setAttribute('spellcheck','false');
    });
  }

  function docKeydown(e){
    const cmd = (e.ctrlKey || e.metaKey) && !e.shiftKey;
    if(cmd && e.key.toLowerCase()==='z'){ e.preventDefault(); undo(); return; }
    const cur=state.cursor; if(!cur) return;
    const isLetter = e.key && /^[A-Za-z]$/.test(e.key);
    if(isLetter){ e.preventDefault(); writeAndAdvance(cur.row,cur.col,e.key,false); return; }
    switch(e.key){
      case 'Backspace': e.preventDefault(); backspaceSmart(); return;
      case ' ': e.preventDefault(); toggleDir(); return;
      case 'Tab': e.preventDefault(); cycleWord(1); return;
      case 'ArrowLeft': e.preventDefault(); moveCursor(-1,0); return;
      case 'ArrowRight': e.preventDefault(); moveCursor(1,0); return;
      case 'ArrowUp': e.preventDefault(); moveCursor(0,-1); return;
      case 'ArrowDown': e.preventDefault(); moveCursor(0,1); return;
      default: return;
    }
  }

  function toggleDir(){ state.dir = state.dir==='across'?'down':'across'; document.getElementById('toggleDir').textContent = `Direction: ${state.dir[0].toUpperCase()+state.dir.slice(1)}`; refreshActive(); }

  // ===== Render helpers =====
  function buildGrid(){
    const rows=puzzle.grid.length, cols=puzzle.grid[0].length;
    const grid = document.createElement('div');
    grid.className='grid';
    grid.style.gridTemplateColumns = `repeat(${cols}, var(--cell))`;
    grid.style.gridTemplateRows = `repeat(${rows}, var(--cell))`;
    cellEls = Array.from({length:rows},()=>Array.from({length:cols},()=>null));

    for(let r=0;r<rows;r++){
      for(let c=0;c<cols;c++){
        const cell = board[r][c];
        const div = document.createElement('div');
        div.className='cell'+(cell.isBlock?' block':'');
        div.dataset.r=r; div.dataset.c=c;
        if(!cell.isBlock){
          if(cell.clueNumber){ const small=document.createElement('span'); small.className='clueNo'; small.textContent=cell.clueNumber; div.appendChild(small); }
          const input=document.createElement('input'); input.value=cell.value||''; input.maxLength=1;
          input.addEventListener('focus',()=>{ setCursor(r,c); });
          input.addEventListener('input',(e)=>{ const ch=(e.target.value||'').replace(/[^A-Za-z]/g,'').toUpperCase(); e.target.value=ch; writeAndAdvance(r,c,ch,false); });
          input.addEventListener('keydown',(e)=> handleKey(e,r,c));
          div.appendChild(input);
        }
        grid.appendChild(div);
        cellEls[r][c] = div;
      }
    }
    gridWrap.innerHTML=''; gridWrap.appendChild(grid);
  }

  function handleKey(e,r,c){
    if(/^([A-Za-z])$/.test(e.key)) return;
    if(e.key==='Backspace'){ e.preventDefault(); backspaceSmart(); return; }
    if(e.key===' '){ e.preventDefault(); toggleDir(); return; }
    if(e.key==='Tab'){ e.preventDefault(); cycleWord(1); return; }
    if(e.key==='ArrowLeft'){ e.preventDefault(); moveCursor(-1,0); return; }
    if(e.key==='ArrowRight'){ e.preventDefault(); moveCursor(1,0); return; }
    if(e.key==='ArrowUp'){ e.preventDefault(); moveCursor(0,-1); return; }
    if(e.key==='ArrowDown'){ e.preventDefault(); moveCursor(0,1); return; }
  }

  function getClueAt(row,col,dir){ const start = findWordStart(row,col,dir); if(!start) return null; const k = `${start.row},${start.col},${dir}`; return clueIdx.get(k) || null; }

  function updateCurrentClue(){
    const cur=state.cursor; if(!cur){ currentClueEl.innerHTML = '<span class="muted">Tap any cell to see its clue</span>'; return; }
    let mainDir = state.dir; let main = getClueAt(cur.row,cur.col,mainDir); let altDir = mainDir==='across'?'down':'across'; let alt = getClueAt(cur.row,cur.col,altDir);
    if(!main && alt){ main = alt; mainDir = altDir; state.dir = mainDir; alt = null; }
    if(!main){ currentClueEl.innerHTML = '<span class="muted">No clue for this cell</span>'; return; }
    const dirLabel = mainDir==='across'?'A':'D'; const mainNum = main.number; const mainEmoji = main.emoji || '';
    const switchHtml = alt ? `<span class="muted" style="margin-left:8px;">Also <button id="switchDirBtn" class="ghost" style="padding:4px 8px; border-radius:999px;">Switch to ${altDir==='across'?'A':'D'}</button></span>` : '';
    const opsHtml = `<span class=\"ops\">
        <button id=\"btnChkW\" class=\"ghost icon\" title=\"Check word\">✓</button>
        <button id=\"btnChkAll\" class=\"ghost\" title=\"Check all\">ALL</button>
        <button id=\"btnRevL\" class=\"ghost icon\" title=\"Reveal letter\">👁</button>
        <button id=\"btnRevW\" class=\"ghost icon\" title=\"Reveal word\" data-badge=\"W\">👁</button>
        <button id=\"btnUndo\" class=\"ghost icon\" title=\"Undo\">↩︎</button>
      </span>`;
    currentClueEl.innerHTML = `
      <div class="emoScroll">
        <span class="pill">${mainNum}${dirLabel}</span>
        <span class="emo">${mainEmoji}</span>
        ${switchHtml}
      </div>
      ${opsHtml}
    `;

    const btn=document.getElementById('switchDirBtn'); if(btn){ btn.onclick=()=>{ state.dir = altDir; document.getElementById('toggleDir').textContent = `Direction: ${state.dir[0].toUpperCase()+state.dir.slice(1)}`; refreshActive(); }; }
    // Ops listeners
    const g=(id)=>document.getElementById(id);
    g('btnChkW').onclick = ()=> check('word');
    g('btnChkAll').onclick = ()=> check('puzzle', true);
    g('btnRevL').onclick = ()=> reveal('letter');
    g('btnRevW').onclick = ()=> reveal('word');
    g('btnUndo').onclick = ()=> undo();
  }

  function focusFirst(){ for(let r=0;r<board.length;r++){ for(let c=0;c<board[0].length;c++){ if(!board[r][c].isBlock){ setCursor(r,c,true); return; } } } }
  function setCursor(r,c,focus=false){ state.cursor={row:r,col:c}; refreshActive(); if(focus){ const el=cellEls[r][c]?.querySelector('input'); if(el) el.blur(); } }

  function refreshActive(){
    for(let r=0;r<cellEls.length;r++){
      for(let c=0;c<cellEls[0].length;c++){
        const el = cellEls[r][c]; if(!el) continue; el.classList.remove('active','selected');
      }
    }
    const cur=state.cursor; if(!cur) return;
    const start = findWordStart(cur.row,cur.col,state.dir);
    const cells = getWordCells(start,state.dir);
    for(const cell of cells){ const el=cellEls[cell.row][cell.col]; if(el) el.classList.add('active'); }
    const sel=cellEls[cur.row][cur.col]; if(sel) sel.classList.add('selected');
    updateCurrentClue();
  }

  function findWordStart(row,col,dir){ if(row<0||col<0||row>=board.length||col>=board[0].length) return null; if(board[row][col].isBlock) return null; let r=row,c=col; if(dir==='across'){ while(c-1>=0 && !board[r][c-1].isBlock) c--; } else { while(r-1>=0 && !board[r-1][c].isBlock) r--; } return {row:r,col:c}; }
  function getWordCells(start,dir){ const out=[]; if(!start) return out; let {row,col}=start; const R=board.length, C=board[0].length; while(row>=0 && row<R && col>=0 && col<C && !board[row][col].isBlock){ out.push(board[row][col]); if(dir==='across') col++; else row++; } return out; }

  function updateCellDom(row,col){ const cell=board[row][col]; const host=cellEls[row][col]; if(!host) return; const input=host.querySelector('input'); if(input && input.value !== (cell.value||'')) input.value = cell.value||''; const wrong = !!cell.value && cell.solution && cell.value !== cell.solution; host.classList.toggle('wrong', wrong); }

  function writeAndAdvance(row,col,ch,back){ const cell=board[row][col]; if(cell.isBlock) return; const prev = cell.value||''; const next = (ch||'').toUpperCase(); if(prev !== next){ history.push({row,col,prev,next}); } cell.value = next; updateCellDom(row,col); const start=findWordStart(row,col,state.dir); const cells=getWordCells(start,state.dir); const idx=cells.findIndex(cc=>cc.row===row&&cc.col===col); if(back){ if(idx>0){ setCursor(cells[idx-1].row, cells[idx-1].col, true); } else { if(state.dir==='across'){ let c=col-1; while(c>=0 && !board[row][c].isBlock){ setCursor(row,c,true); return; } } else { let r=row-1; while(r>=0 && !board[r][col].isBlock){ setCursor(r,col,true); return; } } setCursor(row,col,true); } } else { if(idx < cells.length-1){ setCursor(cells[idx+1].row, cells[idx+1].col, true); } else setCursor(row,col,true); } checkAutoSolved(); }

  function backspaceSmart(){ const cur=state.cursor; if(!cur) return; const cell=board[cur.row][cur.col]; if(cell.value){ writeAndAdvance(cur.row,cur.col,'',true); } else { const start=findWordStart(cur.row,cur.col,state.dir); const cells=getWordCells(start,state.dir); const idx=cells.findIndex(cc=>cc.row===cur.row&&cc.col===cur.col); if(idx>0){ const prev=cells[idx-1]; setCursor(prev.row,prev.col,true); writeAndAdvance(prev.row,prev.col,'',true); } else { if(state.dir==='across'){ let c=cur.col-1; while(c>=0 && !board[cur.row][c].isBlock){ setCursor(cur.row,c,true); writeAndAdvance(cur.row,c,'',true); return; } } else { let r=cur.row-1; while(r>=0 && !board[r][cur.col].isBlock){ setCursor(r,cur.col,true); writeAndAdvance(r,cur.col,'',true); return; } } } } }

  function moveCursor(dx,dy){ const cur=state.cursor; if(!cur) return; let r=cur.row+dy, c=cur.col+dx; const R=board.length,C=board[0].length; while(r>=0&&r<R&&c>=0&&c<C&&board[r][c].isBlock){ r+=dy; c+=dx; } if(r>=0&&r<R&&c>=0&&c<C) setCursor(r,c,true); }
  function cycleWord(step){ const starts=[]; const R=board.length,C=board[0].length; for(let r=0;r<R;r++) for(let c=0;c<C;c++){ if(board[r][c].isBlock) continue; const aStart = (c===0||board[r][c-1].isBlock) && (c+1<C && !board[r][c+1].isBlock); const dStart = (r===0||board[r-1][c].isBlock) && (r+1<R && !board[r+1][c].isBlock); if(aStart) starts.push({row:r,col:c,dir:'across'}); if(dStart) starts.push({row:r,col:c,dir:'down'}); } const cur=state.cursor; const s=findWordStart(cur.row,cur.col,state.dir); const i=starts.findIndex(x=>s&&x.row===s.row&&x.col===s.col&&x.dir===state.dir); const j=(i+step+starts.length)%starts.length; const nxt=starts[j]; state.dir=nxt.dir; setCursor(nxt.row,nxt.col,true); }

  function isAllCorrect(){ for(const row of board){ for(const cell of row){ if(cell.isBlock) continue; if((cell.value||'') !== (cell.solution||'')) return false; } } return true; }
  function checkAutoSolved(){ if(!state.solved && isAllCorrect()){ onPuzzleSolved(false); } }

  function openSurveyModal(){ surveyFrame.src = SURVEY_URL; surveyNewTab.href = SURVEY_URL; surveyModal.style.display = 'flex'; }
  function closeSurveyModal(){ surveyModal.style.display = 'none'; surveyFrame.src = 'about:blank'; }
  function onPuzzleSolved(){ if(state.solved) return; state.solved=true; toast.style.display='block'; setTimeout(()=> toast.style.display='none', 2000); openSurveyModal(); }

  if(surveyClose) surveyClose.onclick = closeSurveyModal;
  if(surveyModal) surveyModal.addEventListener('click', (e)=> { if(e.target===surveyModal) closeSurveyModal(); });

  function reset(){ state.seconds=0; state.running=true; state.solved=false; document.getElementById('status').textContent='Solve the puzzle!'; history.length=0; const rebuilt = buildBoardFromPuzzle(puzzle); board=rebuilt.board; buildGrid(); focusFirst(); applyKeyboardMode(); closeSurveyModal(); }
  function share(){ let out=[]; for(let r=0;r<board.length;r++){ let line=''; for(let c=0;c<board[0].length;c++){ const cell=board[r][c]; if(cell.isBlock) line+='⬛'; else if(!cell.value) line+='⬜'; else line += (cell.value===cell.solution? '🟩':'🟥'); } out.push(line); } const mins=Math.floor(state.seconds/60), secs=String(state.seconds%60).padStart(2,'0'); const text=`${puzzle.title}\nTime ${mins}:${secs}\n${out.join('\n')}`; navigator.clipboard.writeText(text).then(()=> document.getElementById('status').textContent='Copied results to clipboard!'); }

  // ===== Check / Reveal / Undo =====
  function check(kind, fromUser){
    let correctAll=true;
    const mark=(cell)=>{ if(cell.isBlock||!cell.solution) return; const good=(cell.value||'')===cell.solution; cell.isCorrect=good; const el=cellEls[cell.row][cell.col]; if(el){ el.classList.toggle('wrong', !good && !!cell.value); } if(!good) correctAll=false; };
    if(kind==='cell' && state.cursor){ mark(board[state.cursor.row][state.cursor.col]); }
    else if(kind==='word' && state.cursor){ const start=findWordStart(state.cursor.row,state.cursor.col,state.dir); for(const c of getWordCells(start,state.dir)) mark(c); }
    else { for(const row of board) for(const c of row) mark(c); }
    if(kind==='puzzle' && correctAll){ onPuzzleSolved(true); }
    document.getElementById('status').textContent = correctAll? 'All correct!' : 'Some cells are wrong.';
  }

  function reveal(kind){ if(!state.cursor) return; const rev=(cell)=>{ if(cell.isBlock||!cell.solution) return; const prev=cell.value||''; cell.value=cell.solution; history.push({row:cell.row,col:cell.col,prev,next:cell.value}); updateCellDom(cell.row,cell.col); const mark=document.createElement('span'); mark.className='revealedMark'; mark.textContent='👀'; const host=cellEls[cell.row][cell.col]; if(host && !host.querySelector('.revealedMark')) host.appendChild(mark); };
    if(kind==='letter'){ rev(board[state.cursor.row][state.cursor.col]); } else { const start=findWordStart(state.cursor.row,state.cursor.col,state.dir); for(const c of getWordCells(start,state.dir)) rev(c); }
    checkAutoSolved();
  }

  function undo(){ const last = history.pop(); if(!last) return; const {row,col,prev} = last; const cell=board[row][col]; cell.value = prev||''; updateCellDom(row,col); setCursor(row,col,true); }

  // ===== Floating VK =====
  function buildVirtualKeyboard(){
    const rows = [ 'QWERTYUIOP', 'ASDFGHJKL', 'ZXCVBNM' ];
    vk.innerHTML = '';
    for(const r of rows){
      const rowDiv = document.createElement('div'); rowDiv.className='row';
      for(const ch of r.split('')){ const b=document.createElement('button'); b.textContent=ch; b.addEventListener('click',()=> keyPress(ch)); rowDiv.appendChild(b); }
      vk.appendChild(rowDiv);
    }
    const ctl = document.createElement('div'); ctl.className='row';
    const back = document.createElement('button'); back.textContent='⌫'; back.className='action'; back.addEventListener('click',()=> keyPress('BACK'));
    const space = document.createElement('button'); space.textContent='A/D'; space.className='action space'; space.addEventListener('click',()=> keyPress('TOGGLE'));
    const next = document.createElement('button'); next.textContent='Next'; next.className='action'; next.addEventListener('click',()=> keyPress('NEXT'));
    ctl.appendChild(back); ctl.appendChild(space); ctl.appendChild(next);
    vk.appendChild(ctl);

    setVkVisible(true);
  }

  function setVkVisible(show){
    vk.style.display = show ? 'block' : 'none';
    const h = show ? vk.getBoundingClientRect().height : 0;
    document.documentElement.style.setProperty('--vkH', `${Math.ceil(h)}px`);
  }

  function keyPress(code){
    const cur = state.cursor; if(!cur) return;
    if(code==='BACK'){ backspaceSmart(); return; }
    if(code==='TOGGLE'){ toggleDir(); return; }
    if(code==='NEXT'){ cycleWord(1); return; }
    if(/^[A-Z]$/.test(code)){ writeAndAdvance(cur.row,cur.col,code,false); }
  }
})();
</script>
</body>
</html>
